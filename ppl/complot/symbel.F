	SUBROUTINE SYMBEL(X,Y,DEGRES,HEIGHT,NCHAR,STRING)
C** 
C**    @(#)symbel.tplate.F	1.1    3/10/88
C**
C**
C***********************************************************************
C**
C**                 PLOT+ Scientific Graphics System
C**
C***********************************************************************
C**
C**
C
C	CALL SYMBEL(X,Y,DEGRES,HEIGHT,NCHAR,STRING)
C
C	THIS SUBROUTINE DRAWS A STRING OF CHARACTERS.
C
C	THE VARIOUS PARAMETERS AND THEIR DEFINITIONS ARE LISTED
C	BELOW:
C        X,Y    - COORDINATES OF THE LOWER LEFT-HAND CORNER OF
C                 THE FIRST CHARACTER IN USER"S UNITS.
C        DEGRES - ANGLE AT WHICH THE CHARACTERS ARE TO BE DRAWN
C                 IN DEGREES RELATIVE TO THE X-AXIS.
C        HEIGHT - HEIGHT OF THE CHARACTERS IN INCHES (OR MM).
C        NCHAR  - NUMBER OF CHARACTERS TO BE DRAWN.
C        STRING - ARRAY CONTAINING THE DISPLAY CODES OF THE
C                 CHARACTERS TO BE DRAWN.
C
	DIMENSION SX(12000),SY(12000),ASCII(127,4),BASE(4),RAST(4)
	DIMENSION DTYPE(35),DLEN(35),IOFF(4),IFLEN(4),ITYPE(4)
C
	LOGICAL SYMROT,READIR,PLOT,COLRF
c	CHARACTER PLTFIL*80
	CHARACTER ICOM*2,ICHR*1,STRING*120,DNME(35)*2,DNUM(35)*2
	CHARACTER DNAME(35)*80,KIF(4)*2,IFN(4)*2

*       *jd* 7.92 variable IF renamed to KIF for MAC
*       *jd* 11.94 
*       Modification uses TM_NUMBER to determine if "value" is a number rather
*       than the ERR= branch of a READ which fails on AIX/xlf

	CHARACTER*1 KSUB,KSUPER,KBKSP,KCALL,PENS(16)
#ifdef unix
	INTEGER*2 SX,SY
        integer       dirlen
        character*255 fontdir
#else
	byte sx,sy
#endif
	INTEGER*2 ICNT,IBASE,IRAST
	INTEGER*2 ASCII
	INTEGER*2 DTYPE,DLEN,IOFF,IFLEN,ITYPE
	INTEGER COLOLD
	LOGICAL ASCFNT
C
        LOGICAL TM_NUMBER                ! ** TMAP mod 11/94 **

C
#ifdef unix
	INCLUDE 'pplinc/PLTCOM.DAT'
#else
	INCLUDE 'pplinc:PLTCOM.DAT'
#endif
C
	DATA DNUM,DNME/35*'@@',35*'@@'/
#ifdef unix
	DATA KSUB,KSUPER,KBKSP,KCALL/'_','^','\\','@'/
#else
	DATA KSUB,KSUPER,KBKSP,KCALL/'_','^','\','@'/
#endif
	DATA KIF,IFN/'SR','SG','@@','@@','01','12','@@','@@'/
	DATA PENS/'1','2','3','4','5','6','7','8','9','A',
     *	'B','C','D','E','F','G'/
	DATA READIR/.FALSE./
C
C	DEFINE THE SCALE FACTOR TO BE THE AMOUNT OF MAGNIFICATION
C	REQUIRED TO CONVERT THE CHARACTERS IN THE CHARACTER DEFI-
C	NITION TABLE TO THE SIZE SPECIFIED BY THE USER.
C
	COLRF=.FALSE.
	IF(.NOT.READIR)GOTO 2020
2000	SYMSC = HEIGHT * FACTOR / 21.0
C
C	ROTATE THE CHARACTER STRING.
C
	IF(DEGRES .NE. 0.0)GO TO 10
C
C	RESET THE CHARACTER ROTATION FLAG.
C
	SYMROT = .FALSE.
	GO TO 20
C
C	SET THE CHARACTER ROTATION FLAG.
C
10	SYMROT = .TRUE.
C
C	CONVERT THE ROTATION TO RADIANS.
C
	TEMP = 0.01745329251994 * DEGRES
C
C	COMPUTE THE SINE AND COSINE.
C
	SYMSIN = SIN(TEMP)
	SYMCOS = COS(TEMP)
C
C	SET VECTORS MODE.
C
20	PMODE = VECTOR
C
C	START AT THE LOWER LEFT-HAND CORNER OF THE FIRST CHARACTER.
C
	IF(NCHAR .EQ. 0)RETURN
	XTEMP = X * XSCALE
	YTEMP = Y * YSCALE
	PENF = .FALSE.
	PLOT=NCHAR.GT.0
	IF(PLOT)CALL XYZPLT
C
C	INITIALIZE CONTROL VARIABLES.
C
	XORG = XTEMP
	YORG = YTEMP
	XREF = 0.0
	YREF = 0.0
	CHARSC = 1.0
	WIDTH = 0.0
	SLANT = 0.0
	IFONT = 1
	ASCFNT=ITYPE(1).EQ.-1
	SYMWID=0.0
	NCH=IABS(NCHAR)
C
C	DRAW THE CHARACTERS IN THE STRING ONE BY ONE.
C
	JJ=0
	DO 170 I=1,NCH
	JJ=JJ+1
	IF(JJ.GT.NCH)GOTO 180
	ICHR = STRING(JJ:JJ)
C
C	CHECK FOR A CONTROL CHARACTER.
C
	IF(ICHAR(ICHR) .EQ.27)THEN
	    ASCFNT=.FALSE.
	    GOTO 170
	ENDIF
	IF(ICHAR(ICHR) .EQ. 0)GOTO 180
#ifdef unix
	IF(.NOT.ASCFNT.AND.(ICHR.EQ.'@'.OR.
     *		(ICHR.GE.'\\'.AND.ICHR.LE.'_')))GOTO 80
#else
	IF(.NOT.ASCFNT.AND.(ICHR.EQ.'@'.OR.
     *		(ICHR.GE.'\'.AND.ICHR.LE.'_')))GOTO 80
#endif
C
C	CALCULATE POINTER
C
	IF(ITYPE(IFONT).LE.0)THEN
C	    CHARACTER FONT
	    ICODE = ASCII(ICHAR(ICHR),IFONT)
	ELSE
C	    SYMBOL FONT
	    ICOM = STRING(JJ:JJ+1)
	    JJ=JJ+1
	    READ(ICOM,999,IOSTAT=ISTAT)II
999	    FORMAT(I2)
	    IF(ISTAT.EQ.0)THEN
	    	ICODE = ASCII(II,IFONT)
	    ELSE
	        ICODE = 1
	    ENDIF
	ENDIF
	IPOINT = ICODE+IOFF(IFONT)
	XMN=SX(IPOINT)
	XMX=SY(IPOINT)
	IF(XMN.GT.50.)XMN=XMN-100.
	IF(XMX.GT.50.)XMX=XMX-100.
	WIDTH=(XMX-XMN)*CHARSC*RAST(IFONT)
	SYMWID=SYMWID+WIDTH
	IF(.NOT.PLOT)GOTO 70
	IPOINT=IPOINT+1
	PENF = .FALSE.
C
C	DRAW THE CHARACTER
C
30	IX=SX(IPOINT)
	IY=SY(IPOINT)
	IF(IX.GT.50)IX=IX-100
	IF(IY.GT.50)IY=IY-100
	IY=-IY
	IPOINT=IPOINT+1
C
C	CHECK FOR A CONTROL BYTE.
C
	IF(IX .EQ. 50)GO TO 60
C
C	CALCULATE THE NEW PEN COORDINATES RELATIVE TO THE LOWER
C	LEFT-HAND CORNER OF THE FIRST CHARACTER.
C
	XY=FLOAT(IY)-BASE(IFONT)
	XX=FLOAT(IX)-XMN+XY*SLANT
	XSYM =XREF+XX*CHARSC*RAST(IFONT)
	YSYM =YREF+XY*CHARSC*RAST(IFONT)
C
C	SCALE AND ROTATE THE NEW COORDINATES.
C
	IF(SYMROT)GO TO 40
	XTEMP = XSYM * SYMSC + XORG
	YTEMP = YSYM * SYMSC + YORG
	GO TO 50
40	XTEMP = (XSYM * SYMCOS - YSYM * SYMSIN) * SYMSC + XORG
	YTEMP = (XSYM * SYMSIN + YSYM * SYMCOS) * SYMSC + YORG
C
C	MOVE THE PEN TO THE NEW COORDINATES.
C
50	CALL XYZPLT
	PENF = .TRUE.
	GO TO 30
C
C	CHECK FOR THE END OF THE CHARACTER.
C
60	IF(IY .EQ. -50)GO TO 70
	PENF = .FALSE.
	GO TO 30
C
C	ADJUST THE REFERENCE POSITION TO TAKE INTO ACCOUNT THE
C	CHARACTER THAT WAS JUST DRAWN.
C
70	XREF = XREF + WIDTH
	IF(CHARSC .EQ. 1.0)GO TO 169
C	XREF = XREF - 16.*(1.-CHARSC)*RAST(IFONT)
	YREF = 0.0
	CHARSC = 1.0
	GO TO 169
C
C	PROCESS CONTROL CHARACTERS.
C
80	IF(ICHR .NE. KSUB)GO TO 150
	CHARSC = 0.75
C	XREF = XREF + 16.*(1.-CHARSC)*RAST(IFONT)
	YREF=-11.*CHARSC*RAST(IFONT)
	GO TO 169
150	IF(ICHR .NE. KSUPER)GO TO 160
	CHARSC = 0.75
C	XREF = XREF + 16.*(1.-CHARSC)*RAST(IFONT)
	YREF=21.-11.*CHARSC*RAST(IFONT)
	GO TO 169
160	IF(ICHR .NE. KBKSP)GO TO 310
	SYMWID=SYMWID-WIDTH
	XREF = XREF - WIDTH
	WIDTH = 0.0
	GOTO 169
310	IF(ICHR.NE.KCALL)GOTO 169
C
C	UNPACK COMMAND
C
	ICOM = STRING(JJ+1:JJ+2)
	JJ=JJ+2
C
C	PROCESS COMMAND
C
	CALL UPPER(ICOM,2)
	IF(ICOM.EQ.'CL')THEN
C
C	    CLEAR ALL FONTS FROM THE BUFFERS
C
	    DO 1002 II=1,4
	    IOFF(II)=12000
	    IFLEN(II)=0
	    KIF(II)='@@'
	    IFN(II)='@@'
	    ITYPE(II)=0
	    BASE(II)=-9.
1002	    RAST(II)=1.
	    IOFF(1)=0
	    GOTO 169
        ELSE IF(ICOM(1:1).EQ.'C')THEN
C
C           LOOK FOR EXTENDED COLOR COMMAND OF THE FORM
C           @Cnnn WHERE nnn IS A 3 DIGIT NUMBER
C
            IF(.NOT.COLRF)COLOLD=COLOUR
            COLRF=.TRUE.
C
C           SEE IF THE FIRST CHARACTER IS A NUMBER
C
            DO 2050 K=1,9
                IF(ICOM(2:2).EQ.PENS(K))GOTO 2051
2050        CONTINUE
C
C           NO NUMBER FOUND - MUST BE A FONT CHANGE COMMAND
C
            IF(ICOM(2:2).NE.'0')GOTO 2010
2051        JJ=JJ+2
C
C           GET THE 3 DIGIT NUMBER
C
#ifdef AIX_XLF
            IF ( .NOT.TM_NUMBER(STRING(JJ-2:JJ)) ) GOTO 169  
!** TMAP mod 11/94 **
#endif
            READ(STRING(JJ-2:JJ),'(I3)',ERR=169)K
            IF(.NOT.PLOT)GOTO 169
            CALL COLOR(K)
	ELSE IF(ICOM(1:1).EQ.'P')THEN
C
C	    CHANGE PEN/COLOR
C
	    IF(.NOT.PLOT)GOTO 169
	    IF(.NOT.COLRF)COLOLD=COLOUR
	    COLRF=.TRUE.
	    DO 2030 K=1,16
	    IF(ICOM(2:2).EQ.PENS(K))GOTO 2031
2030	    CONTINUE
	    IF(ICOM(2:2).NE.'0')GOTO 2010
	    K=1
2031	    CALL COLOR(K)
	    GOTO 169
	ELSE IF(ICOM(1:1).EQ.'Z')THEN
	    DO 2040 K=1,16
	    IF(ICOM(2:2).EQ.PENS(K))GOTO 2041
2040	    CONTINUE
	    IF(ICOM(2:2).NE.'0')GOTO 2010
	    K=0
2041	    SLANT=SIN(K*0.08726646)
	    GOTO 169
	ENDIF
C	SEARCH FOR FONT BY NAME THEN BY NUMBER
2010	DO 1003 K=1,4
	IF(ICOM.EQ.KIF(K).OR.ICOM.EQ.IFN(K))GOTO 302
1003	CONTINUE
C	NOT FOUND SEARCH MAIN DIRECTORY
	DO 1004 ID=1,NFNT
	IF(ICOM.EQ.DNME(ID).OR.ICOM.EQ.DNUM(ID))GOTO 1001
1004	CONTINUE
C	FONT NOT FOUND USE LAST FONT
	GOTO 169
1001	ILEN=DLEN(ID)
C
C	FIND WHERE FONT WILL FIT
C
	DO 1005 II=4,1,-1
	IF(ILEN+IOFF(II).LE.12000)GOTO 1010
1005	CONTINUE
C
C	ERROR IF NO ROOM ANYWHERE!
C
	GOTO 169
c1006	IF(.NOT.NEWFIL)THEN
c	    INQUIRE(UNIT=LUHP,NAME=PLTFIL)
c	    CLOSE(LUHP)
c	ENDIF
#ifdef unix
1010	OPEN(LUSY,FILE=fontdir(:dirlen)//DNAME(ID),STATUS='OLD',
     *	FORM='UNFORMATTED',ERR=169)
#else
1010	open(lusy,file=dname(id),status='old',readonly,
     *	form='unformatted',err=169)
#endif
C
C	SETUP FOR NEW FONT
C
	IFONT=II
	KIF(II)=DNME(ID)
	IFN(II)=DNUM(ID)
	ITYPE(II)=DTYPE(ID)
	IFLEN(II)=DLEN(ID)
C
C	SETUP IOFF
C
	IF(II.EQ.4)GOTO 1008
	DO 1007 IJ=II+1,4
	IOFF(IJ)=12000
	KIF(IJ)='@@'
	IFN(IJ)='@@'
1007	IFLEN(IJ)=0
	IOFF(II+1)=IOFF(II)+IFLEN(II)
C
C	READ NEW FONT
C
1008	READ(LUSY)ICNT,IBASE,IRAST
	READ(LUSY)(ASCII(IJ,II),IJ=1,127)
	BASE(II)=FLOAT(IBASE)
	RAST(II)=21./FLOAT(IRAST)
	IADD=IOFF(II)+1
	READ(LUSY)(SX(IJ),IJ=IADD,IADD+DLEN(ID)-1)
	READ(LUSY)(SY(IJ),IJ=IADD,IADD+DLEN(ID)-1)
	CLOSE(LUSY)
c	IF(.NOT.NEWFIL)THEN
c	    IF(PTYPE.EQ.0 .OR. PTYPE.EQ.2 .OR. PTYPE.EQ.4)THEN
c		OPEN(LUHP,FILE=PLTFIL,FORM='UNFORMATTED',STATUS='OLD',
c     *		ACCESS='APPEND')
c	    ELSE
c		OPEN(LUHP,FILE=PLTFIL,STATUS='OLD',ACCESS='APPEND')
c	    ENDIF
c	ENDIF
C
C	DONE
C
	IF(READIR)GOTO 169
	READIR=.TRUE.
	GOTO 2000
C
C	READ DIRECTORY
C
c2020	IF(.NOT.NEWFIL)THEN
c	    INQUIRE(UNIT=LUHP,NAME=PLTFIL)
c	    CLOSE(LUHP)
c	ENDIF
#ifdef unix
C *JD* Mod below fix for unix  -- use environment variable 3.19.91
C2020	OPEN(LUSY,FILE='FONTFIL',

 2020   call getenv ('PLOTFONTS',fontdir)
        dirlen = lnblk (fontdir,255)

	OPEN(LUSY,FILE=fontdir(:dirlen)//'fondat.dat',
     *	STATUS='OLD')
#else
2020	open(lusy,file='plotfonts:fondat.dat',readonly,
     *	status='old')
#endif
C
C	FILE EXISTS
C
	READ(LUSY,983,END=1009)(DNUM(IJ),DNME(IJ),DTYPE(IJ),
     *	DLEN(IJ),DNAME(IJ),IJ=1,35)
#ifdef unix
C Mod here from A to A9 for read of DNAME *JD* 3.8.91
C983	FORMAT(1X,2A2,I2,I5,A)
983	FORMAT(1X,2A2,I2,I5,A9)
#else
983	format(1x,2a2,i2,i5,a30)
#endif
1009	NFNT=IJ-1
    	CLOSE(LUSY)
C
C	READ DEFAULT FONT
C
	IOFF(1)=0
	II=1
	ID=1
	GOTO 1010
302	IFONT=K
169	ASCFNT=ITYPE(IFONT).EQ.-1
170	CONTINUE
180	IF(.NOT.PLOT)THEN
	    X=SYMWID*HEIGHT/21.
	    RETURN
	END IF
C
C	SCALE AND ROTATE THE FINAL COORDINATES.
C
	IF(SYMROT)GO TO 190
	XTEMP = XREF * SYMSC + XORG
	YTEMP = YORG
	GO TO 200
190	XTEMP = XREF * SYMCOS * SYMSC + XORG
	YTEMP = XREF * SYMSIN * SYMSC + YORG
C
C	PLOT TO THE END OF THE CHARACTER STRING.
C
200	PENF = .FALSE.
	CALL XYZPLT
C
C	RESET COLOR
C
	IF(COLRF.AND.(COLOLD.NE.COLOUR))CALL COLOR(COLOLD)
	RETURN
C
	END
	FUNCTION SYMWID(HEIGHT,NCHAR,STRING)
	CHARACTER STRING*255
	NC=-IABS(NCHAR)
C
C	THIS FUNCTION RETURNS THE WIDTH OF THE STRING WITHOUT DRAWING IT
C
	SS=0.
	CALL SYMBEL(SS,0.,0.,HEIGHT,NC,STRING)
	SYMWID=SS
	RETURN
	END























